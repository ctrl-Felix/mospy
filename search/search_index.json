{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MosPy MosPy is a cosmospy fork and aims to be a versatile transaction signing library for the whole cosmos ecosystem. Installation Currently the only way to install mospy is by installing it directly from the github repository: python -m pip install git+https://github.com/ctrl-Felix/mospy.git","title":"MosPy"},{"location":"#mospy","text":"MosPy is a cosmospy fork and aims to be a versatile transaction signing library for the whole cosmos ecosystem.","title":"MosPy"},{"location":"#installation","text":"Currently the only way to install mospy is by installing it directly from the github repository: python -m pip install git+https://github.com/ctrl-Felix/mospy.git","title":"Installation"},{"location":"account/","text":"The account class can be instantiated through a seed or a private key. If nothing is provided it will create a new keyring and the params to work with the cosmos chain Note You can't provide a seed_phrase and a private_key A readble method behaves is the getter for a Attribute (Example: hrp = account.hrp ) A writable method is the setter for the Attribute (Example: account.hrp = \"cosmos\" ) A method can be setter and getter at the same time. The Parameters description always refers to the setter while the Returns section belongs to the getter Parameters: Name Type Description Default seed_phrase str Seed phrase to derive private keys from None private_key str Private key to instantiate the Account None next_sequence int Sequence which will be used for transactions signed with this Account None account_number int On-chain account number None slip44 int Slip44 value 118 hrp str Address Prefix 'cosmos' address_index int Address index to get sub accounts for seed phrases (doesn't work when using a private key) 0 Source code in mospy\\Account.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class Account : \"\"\" The account class can be instantiated through a seed or a private key. If nothing is provided it will create a new keyring and the params to work with the cosmos chain Note: * You can't provide a ``seed_phrase`` and a``private_key`` * A ``readble`` method behaves is the getter for a Attribute (Example: ``hrp = account.hrp``) * A ``writable`` method is the setter for the Attribute (Example: ``account.hrp = \"cosmos\"``) * A method can be setter and getter at the same time. The Parameters description always refers to the setter while the Returns section belongs to the getter Args: seed_phrase (str): Seed phrase to derive private keys from private_key (str): Private key to instantiate the Account next_sequence (int): Sequence which will be used for transactions signed with this Account account_number (int): On-chain account number slip44 (int): Slip44 value hrp (str): Address Prefix address_index (int): Address index to get sub accounts for seed phrases (doesn't work when using a private key) \"\"\" address : str \"\"\"the address of the account derived by using the slip44 param, the hrp and the address_index\"\"\" _RAW_DERIVATION_PATH = \"m/44'/ {slip44} '/0'/0/ {address_index} \" def __init__ ( self , seed_phrase : str = None , private_key : str = None , next_sequence : int = None , account_number : int = None , slip44 : int = 118 , hrp : str = \"cosmos\" , address_index : int = 0 , ): self . _slip44 = slip44 self . _hrp = hrp self . _address_index = address_index self . _next_sequence = next_sequence self . _account_number = account_number if not seed_phrase and not private_key : self . _seed_phrase = Mnemonic ( language = \"english\" ) . generate ( strength = 256 ) self . _private_key = seed_to_private_key ( seed_phrase , self . _derivation_path ()) elif seed_phrase and not private_key : self . _seed_phrase = seed_phrase self . _private_key = seed_to_private_key ( seed_phrase , self . _derivation_path ()) elif private_key and not seed_phrase : self . _seed_phrase = None self . _private_key = bytes . fromhex ( private_key ) else : raise AttributeError ( \"Please set only a private key or a seed phrase. Not both!\" ) def _derivation_path ( self , address_index : int = None ): adr_id = self . _address_index if not address_index else address_index params = { \"slip44\" : self . _slip44 , \"address_index\" : adr_id } return self . _RAW_DERIVATION_PATH . format ( ** params ) @property def address ( self ) -> str : \"\"\" Current address which depends on the hrp and the private key Returns: Private Key \"\"\" if not self . _seed_phrase : address = privkey_to_address ( self . _private_key , hrp = self . _hrp ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_address ( sub_private_key , hrp = self . _hrp ) return address @property def private_key ( self ) -> bytes : \"\"\" Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Private Key \"\"\" if self . _seed_phrase : private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) return private_key else : return self . _private_key @property def public_key ( self ) -> keys . PubKey : \"\"\" Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Public Key \"\"\" pubkey_bytes = privkey_to_pubkey ( self . private_key ) _pubkey = keys . PubKey () _pubkey . key = pubkey_bytes return _pubkey @property def account_number ( self ) -> int : \"\"\" On-chain account number which will be assigned when the address receives coins for the first time. Args: account_number (int): Account Number Returns: Account number \"\"\" return self . _account_number @account_number . setter def account_number ( self , account_number : int ): self . _account_number = account_number @property def next_sequence ( self ) -> int : \"\"\" Sequence which will be used for transactions signed with this Account. Args: next_sequence (int): Next sequence (only when used as setter) Returns: Next Sequence \"\"\" return self . _next_sequence @next_sequence . setter def next_sequence ( self , next_sequence ): self . _next_sequence = next_sequence def increase_sequence ( self , change : int = 1 ) -> None : \"\"\" Increase the sequence by ``change`` Args: change (int): Value to increase the sequence \"\"\" self . _next_sequence += change @property def address_index ( self ): \"\"\" Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Args: address_index (int): New address index Returns: Address Index \"\"\" return self . _address_index @address_index . setter def address_index ( self , address_index : int ) -> None : if self . _seed_phrase : self . _DEFAULT_ADDRESS_INDEX = address_index else : raise ValueError ( \"Can't the change the address index without provided seed\" ) @property def hrp ( self ) -> str : \"\"\" Current address prefix used by the Account. Returns: Address Prefix (hrp) \"\"\" return self . _hrp @hrp . setter def hrp ( self , hrp : str ) -> None : self . _hrp = hrp @property def slip44 ( self , slip44 : int ) -> None : \"\"\" Current slip44 value Args: slip44 (int): New slip44 value as defined in the [slip44 registry](https://github.com/satoshilabs/slips/blob/master/slip-0044.md) Returns: Slip44 \"\"\" return self . _slip44 @slip44 . setter def set_slip44 ( self , slip44 : int ) -> None : self . _slip44 = slip44 account_number () writable property On-chain account number which will be assigned when the address receives coins for the first time. Parameters: Name Type Description Default account_number int Account Number required Returns: Type Description int Account number Source code in mospy\\Account.py 125 126 127 128 129 130 131 132 133 134 135 @property def account_number ( self ) -> int : \"\"\" On-chain account number which will be assigned when the address receives coins for the first time. Args: account_number (int): Account Number Returns: Account number \"\"\" return self . _account_number address () property Current address which depends on the hrp and the private key Returns: Type Description str Private Key Source code in mospy\\Account.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @property def address ( self ) -> str : \"\"\" Current address which depends on the hrp and the private key Returns: Private Key \"\"\" if not self . _seed_phrase : address = privkey_to_address ( self . _private_key , hrp = self . _hrp ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_address ( sub_private_key , hrp = self . _hrp ) return address address_index () writable property Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Parameters: Name Type Description Default address_index int New address index required Returns: Type Description Address Index Source code in mospy\\Account.py 167 168 169 170 171 172 173 174 175 176 177 178 @property def address_index ( self ): \"\"\" Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Args: address_index (int): New address index Returns: Address Index \"\"\" return self . _address_index hrp () writable property Current address prefix used by the Account. Returns: Type Description str Address Prefix (hrp) Source code in mospy\\Account.py 189 190 191 192 193 194 195 196 197 @property def hrp ( self ) -> str : \"\"\" Current address prefix used by the Account. Returns: Address Prefix (hrp) \"\"\" return self . _hrp increase_sequence ( change = 1 ) Increase the sequence by change Parameters: Name Type Description Default change int Value to increase the sequence 1 Source code in mospy\\Account.py 158 159 160 161 162 163 164 165 def increase_sequence ( self , change : int = 1 ) -> None : \"\"\" Increase the sequence by ``change`` Args: change (int): Value to increase the sequence \"\"\" self . _next_sequence += change next_sequence () writable property Sequence which will be used for transactions signed with this Account. Parameters: Name Type Description Default next_sequence int Next sequence (only when used as setter) required Returns: Type Description int Next Sequence Source code in mospy\\Account.py 141 142 143 144 145 146 147 148 149 150 151 152 @property def next_sequence ( self ) -> int : \"\"\" Sequence which will be used for transactions signed with this Account. Args: next_sequence (int): Next sequence (only when used as setter) Returns: Next Sequence \"\"\" return self . _next_sequence private_key () property Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description bytes Private Key Source code in mospy\\Account.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @property def private_key ( self ) -> bytes : \"\"\" Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Private Key \"\"\" if self . _seed_phrase : private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) return private_key else : return self . _private_key public_key () property Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description keys . PubKey Public Key Source code in mospy\\Account.py 112 113 114 115 116 117 118 119 120 121 122 123 @property def public_key ( self ) -> keys . PubKey : \"\"\" Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Public Key \"\"\" pubkey_bytes = privkey_to_pubkey ( self . private_key ) _pubkey = keys . PubKey () _pubkey . key = pubkey_bytes return _pubkey slip44 ( slip44 ) writable property Current slip44 value Parameters: Name Type Description Default slip44 int New slip44 value as defined in the slip44 registry required Returns: Type Description None Slip44 Source code in mospy\\Account.py 203 204 205 206 207 208 209 210 211 212 213 214 215 @property def slip44 ( self , slip44 : int ) -> None : \"\"\" Current slip44 value Args: slip44 (int): New slip44 value as defined in the [slip44 registry](https://github.com/satoshilabs/slips/blob/master/slip-0044.md) Returns: Slip44 \"\"\" return self . _slip44","title":"Account"},{"location":"account/#mospy.Account.Account.account_number","text":"On-chain account number which will be assigned when the address receives coins for the first time. Parameters: Name Type Description Default account_number int Account Number required Returns: Type Description int Account number Source code in mospy\\Account.py 125 126 127 128 129 130 131 132 133 134 135 @property def account_number ( self ) -> int : \"\"\" On-chain account number which will be assigned when the address receives coins for the first time. Args: account_number (int): Account Number Returns: Account number \"\"\" return self . _account_number","title":"account_number()"},{"location":"account/#mospy.Account.Account.address","text":"Current address which depends on the hrp and the private key Returns: Type Description str Private Key Source code in mospy\\Account.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @property def address ( self ) -> str : \"\"\" Current address which depends on the hrp and the private key Returns: Private Key \"\"\" if not self . _seed_phrase : address = privkey_to_address ( self . _private_key , hrp = self . _hrp ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_address ( sub_private_key , hrp = self . _hrp ) return address","title":"address()"},{"location":"account/#mospy.Account.Account.address_index","text":"Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Parameters: Name Type Description Default address_index int New address index required Returns: Type Description Address Index Source code in mospy\\Account.py 167 168 169 170 171 172 173 174 175 176 177 178 @property def address_index ( self ): \"\"\" Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Args: address_index (int): New address index Returns: Address Index \"\"\" return self . _address_index","title":"address_index()"},{"location":"account/#mospy.Account.Account.hrp","text":"Current address prefix used by the Account. Returns: Type Description str Address Prefix (hrp) Source code in mospy\\Account.py 189 190 191 192 193 194 195 196 197 @property def hrp ( self ) -> str : \"\"\" Current address prefix used by the Account. Returns: Address Prefix (hrp) \"\"\" return self . _hrp","title":"hrp()"},{"location":"account/#mospy.Account.Account.increase_sequence","text":"Increase the sequence by change Parameters: Name Type Description Default change int Value to increase the sequence 1 Source code in mospy\\Account.py 158 159 160 161 162 163 164 165 def increase_sequence ( self , change : int = 1 ) -> None : \"\"\" Increase the sequence by ``change`` Args: change (int): Value to increase the sequence \"\"\" self . _next_sequence += change","title":"increase_sequence()"},{"location":"account/#mospy.Account.Account.next_sequence","text":"Sequence which will be used for transactions signed with this Account. Parameters: Name Type Description Default next_sequence int Next sequence (only when used as setter) required Returns: Type Description int Next Sequence Source code in mospy\\Account.py 141 142 143 144 145 146 147 148 149 150 151 152 @property def next_sequence ( self ) -> int : \"\"\" Sequence which will be used for transactions signed with this Account. Args: next_sequence (int): Next sequence (only when used as setter) Returns: Next Sequence \"\"\" return self . _next_sequence","title":"next_sequence()"},{"location":"account/#mospy.Account.Account.private_key","text":"Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description bytes Private Key Source code in mospy\\Account.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @property def private_key ( self ) -> bytes : \"\"\" Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Private Key \"\"\" if self . _seed_phrase : private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) return private_key else : return self . _private_key","title":"private_key()"},{"location":"account/#mospy.Account.Account.public_key","text":"Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description keys . PubKey Public Key Source code in mospy\\Account.py 112 113 114 115 116 117 118 119 120 121 122 123 @property def public_key ( self ) -> keys . PubKey : \"\"\" Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Public Key \"\"\" pubkey_bytes = privkey_to_pubkey ( self . private_key ) _pubkey = keys . PubKey () _pubkey . key = pubkey_bytes return _pubkey","title":"public_key()"},{"location":"account/#mospy.Account.Account.slip44","text":"Current slip44 value Parameters: Name Type Description Default slip44 int New slip44 value as defined in the slip44 registry required Returns: Type Description None Slip44 Source code in mospy\\Account.py 203 204 205 206 207 208 209 210 211 212 213 214 215 @property def slip44 ( self , slip44 : int ) -> None : \"\"\" Current slip44 value Args: slip44 (int): New slip44 value as defined in the [slip44 registry](https://github.com/satoshilabs/slips/blob/master/slip-0044.md) Returns: Slip44 \"\"\" return self . _slip44","title":"slip44()"},{"location":"transaction/","text":"Class to create and sign a transaction Parameters: Name Type Description Default account Account Account object to sign this transaction required gas int Gas unit for this transaction required fee coin The fee to pay for this transaction (This can also be added later through the set_fee method) None memo str Memo '' chain_id str Chain-Id \"cosmoshub-4\", 'cosmoshub-4' Source code in mospy\\Transaction.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class Transaction : \"\"\"Class to create and sign a transaction Args: account (Account): Account object to sign this transaction gas (int): Gas unit for this transaction fee (coin): The fee to pay for this transaction (This can also be added later through the ``set_fee`` method) memo (str): Memo chain_id (str): Chain-Id \"cosmoshub-4\", \"\"\" def __init__ ( self , * , account : Account , gas : int , fee : coin = None , memo : str = \"\" , chain_id : str = \"cosmoshub-4\" , ) -> None : self . _account = account self . _fee = fee self . _gas = gas self . _chain_id = chain_id self . _tx_body = tx . TxBody () self . _tx_body . memo = memo self . _tx_raw = tx . TxRaw () def add_msg ( self , tx_type : str , ** kwargs ) -> None : \"\"\" Add a pre-defined message to the tx body. Args: tx_type (str): Transaction type to match the transaction with the pre-defined ones **kwargs: Depending on the transaction type \"\"\" msg_data = built_in_transactions [ tx_type ]( ** kwargs ) . format () self . add_raw_msg ( msg_data [ 1 ], type_url = msg_data [ 0 ]) def add_raw_msg ( self , unpacked_msg , type_url : str ) -> None : \"\"\" Add a message to the tx body manually. Args: unpacked_msg: Transaction data type_url: Type url for the transaction \"\"\" msg_any = any . Any () msg_any . Pack ( unpacked_msg ) msg_any . type_url = type_url self . _tx_body . messages . append ( msg_any ) def set_fee ( self , amount : int , denom : str = \"uatom\" ): \"\"\" Set the fee manually Args: amount: Amount denom: Denom \"\"\" self . _fee = coin . Coin ( amount = str ( amount ), denom = denom ) def get_tx_bytes ( self ) -> str : \"\"\"Sign the transaction and get the tx bytes which can be then used to broadcast the transaction to the network. Returns: tx_bytes (str): Transaction bytes \"\"\" self . _tx_raw . body_bytes = self . _tx_body . SerializeToString () self . _tx_raw . auth_info_bytes = self . _get_auth_info () . SerializeToString ( ) self . _tx_raw . signatures . append ( self . _get_signatures ()) raw_tx = self . _tx_raw . SerializeToString () tx_bytes = bytes ( raw_tx ) tx_b64 = base64 . b64encode ( tx_bytes ) . decode ( \"utf-8\" ) return tx_b64 def _get_signatures ( self ): privkey = ecdsa . SigningKey . from_string ( self . _account . private_key , curve = ecdsa . SECP256k1 ) signature_compact = privkey . sign_deterministic ( self . _get_sign_doc () . SerializeToString (), hashfunc = hashlib . sha256 , sigencode = ecdsa . util . sigencode_string_canonize , ) return signature_compact def _get_sign_doc ( self ): sign_doc = tx . SignDoc () sign_doc . body_bytes = self . _tx_body . SerializeToString () sign_doc . auth_info_bytes = self . _get_auth_info () . SerializeToString () sign_doc . chain_id = self . _chain_id sign_doc . account_number = self . _account . account_number return sign_doc def _get_auth_info ( self ): _auth_info = tx . AuthInfo () _auth_info . signer_infos . append ( self . _get_signer_infos ()) _auth_info . fee . gas_limit = self . _gas _auth_info . fee . amount . append ( self . _fee ) return _auth_info def _get_signer_infos ( self ): signer_infos = tx . SignerInfo () signer_infos . sequence = self . _account . next_sequence signer_infos . public_key . Pack ( self . _account . public_key ) signer_infos . public_key . type_url = \"/cosmos.crypto.secp256k1.PubKey\" signer_infos . mode_info . single . mode = 1 return signer_infos add_msg ( tx_type , ** kwargs ) Add a pre-defined message to the tx body. Parameters: Name Type Description Default tx_type str Transaction type to match the transaction with the pre-defined ones required **kwargs Depending on the transaction type {} Source code in mospy\\Transaction.py 49 50 51 52 53 54 55 56 57 58 def add_msg ( self , tx_type : str , ** kwargs ) -> None : \"\"\" Add a pre-defined message to the tx body. Args: tx_type (str): Transaction type to match the transaction with the pre-defined ones **kwargs: Depending on the transaction type \"\"\" msg_data = built_in_transactions [ tx_type ]( ** kwargs ) . format () self . add_raw_msg ( msg_data [ 1 ], type_url = msg_data [ 0 ]) add_raw_msg ( unpacked_msg , type_url ) Add a message to the tx body manually. Parameters: Name Type Description Default unpacked_msg Transaction data required type_url str Type url for the transaction required Source code in mospy\\Transaction.py 60 61 62 63 64 65 66 67 68 69 70 71 def add_raw_msg ( self , unpacked_msg , type_url : str ) -> None : \"\"\" Add a message to the tx body manually. Args: unpacked_msg: Transaction data type_url: Type url for the transaction \"\"\" msg_any = any . Any () msg_any . Pack ( unpacked_msg ) msg_any . type_url = type_url self . _tx_body . messages . append ( msg_any ) get_tx_bytes () Sign the transaction and get the tx bytes which can be then used to broadcast the transaction to the network. Returns: Name Type Description tx_bytes str Transaction bytes Source code in mospy\\Transaction.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def get_tx_bytes ( self ) -> str : \"\"\"Sign the transaction and get the tx bytes which can be then used to broadcast the transaction to the network. Returns: tx_bytes (str): Transaction bytes \"\"\" self . _tx_raw . body_bytes = self . _tx_body . SerializeToString () self . _tx_raw . auth_info_bytes = self . _get_auth_info () . SerializeToString ( ) self . _tx_raw . signatures . append ( self . _get_signatures ()) raw_tx = self . _tx_raw . SerializeToString () tx_bytes = bytes ( raw_tx ) tx_b64 = base64 . b64encode ( tx_bytes ) . decode ( \"utf-8\" ) return tx_b64 set_fee ( amount , denom = 'uatom' ) Set the fee manually Parameters: Name Type Description Default amount int Amount required denom str Denom 'uatom' Source code in mospy\\Transaction.py 73 74 75 76 77 78 79 80 81 def set_fee ( self , amount : int , denom : str = \"uatom\" ): \"\"\" Set the fee manually Args: amount: Amount denom: Denom \"\"\" self . _fee = coin . Coin ( amount = str ( amount ), denom = denom )","title":"Transaction"},{"location":"transaction/#mospy.Transaction.Transaction.add_msg","text":"Add a pre-defined message to the tx body. Parameters: Name Type Description Default tx_type str Transaction type to match the transaction with the pre-defined ones required **kwargs Depending on the transaction type {} Source code in mospy\\Transaction.py 49 50 51 52 53 54 55 56 57 58 def add_msg ( self , tx_type : str , ** kwargs ) -> None : \"\"\" Add a pre-defined message to the tx body. Args: tx_type (str): Transaction type to match the transaction with the pre-defined ones **kwargs: Depending on the transaction type \"\"\" msg_data = built_in_transactions [ tx_type ]( ** kwargs ) . format () self . add_raw_msg ( msg_data [ 1 ], type_url = msg_data [ 0 ])","title":"add_msg()"},{"location":"transaction/#mospy.Transaction.Transaction.add_raw_msg","text":"Add a message to the tx body manually. Parameters: Name Type Description Default unpacked_msg Transaction data required type_url str Type url for the transaction required Source code in mospy\\Transaction.py 60 61 62 63 64 65 66 67 68 69 70 71 def add_raw_msg ( self , unpacked_msg , type_url : str ) -> None : \"\"\" Add a message to the tx body manually. Args: unpacked_msg: Transaction data type_url: Type url for the transaction \"\"\" msg_any = any . Any () msg_any . Pack ( unpacked_msg ) msg_any . type_url = type_url self . _tx_body . messages . append ( msg_any )","title":"add_raw_msg()"},{"location":"transaction/#mospy.Transaction.Transaction.get_tx_bytes","text":"Sign the transaction and get the tx bytes which can be then used to broadcast the transaction to the network. Returns: Name Type Description tx_bytes str Transaction bytes Source code in mospy\\Transaction.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def get_tx_bytes ( self ) -> str : \"\"\"Sign the transaction and get the tx bytes which can be then used to broadcast the transaction to the network. Returns: tx_bytes (str): Transaction bytes \"\"\" self . _tx_raw . body_bytes = self . _tx_body . SerializeToString () self . _tx_raw . auth_info_bytes = self . _get_auth_info () . SerializeToString ( ) self . _tx_raw . signatures . append ( self . _get_signatures ()) raw_tx = self . _tx_raw . SerializeToString () tx_bytes = bytes ( raw_tx ) tx_b64 = base64 . b64encode ( tx_bytes ) . decode ( \"utf-8\" ) return tx_b64","title":"get_tx_bytes()"},{"location":"transaction/#mospy.Transaction.Transaction.set_fee","text":"Set the fee manually Parameters: Name Type Description Default amount int Amount required denom str Denom 'uatom' Source code in mospy\\Transaction.py 73 74 75 76 77 78 79 80 81 def set_fee ( self , amount : int , denom : str = \"uatom\" ): \"\"\" Set the fee manually Args: amount: Amount denom: Denom \"\"\" self . _fee = coin . Coin ( amount = str ( amount ), denom = denom )","title":"set_fee()"},{"location":"clients/","text":"Clients The client classes contain helper functions supporting you while interacting with the chain. Supported Endpoints API: HTTPClient","title":"Clients"},{"location":"clients/#clients","text":"The client classes contain helper functions supporting you while interacting with the chain.","title":"Clients"},{"location":"clients/#supported-endpoints","text":"API: HTTPClient","title":"Supported Endpoints"},{"location":"clients/httpclient/","text":"HTTPClient Wrapper class to interact with a cosmos chain through their API endpoint Parameters: Name Type Description Default api str URL to a Cosmos api node 'https://api.cosmos.network' Source code in mospy\\clients\\HTTPClient.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class HTTPClient : \"\"\" Wrapper class to interact with a cosmos chain through their API endpoint Args: api (str): URL to a Cosmos api node \"\"\" def __init__ ( self , * , api : str = \"https://api.cosmos.network\" ): self . _api = api def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: tx (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return [ hash , log ] broadcast_transaction ( * , transaction , timeout = 10 ) Sign and broadcast a transaction. Note Takes only positional arguments Parameters: Name Type Description Default tx Transaction The transaction object required timeout int Timeout 10 Returns: Name Type Description hash [ str , str ] Transaction hash log [ str , str ] Log (None if transaction successful) Source code in mospy\\clients\\HTTPClient.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: tx (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return [ hash , log ] load_account_data ( account ) Load the next_sequence and account_number into the account object. Parameters: Name Type Description Default account Account Account required Source code in mospy\\clients\\HTTPClient.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number","title":"Httpclient"},{"location":"clients/httpclient/#httpclient","text":"Wrapper class to interact with a cosmos chain through their API endpoint Parameters: Name Type Description Default api str URL to a Cosmos api node 'https://api.cosmos.network' Source code in mospy\\clients\\HTTPClient.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class HTTPClient : \"\"\" Wrapper class to interact with a cosmos chain through their API endpoint Args: api (str): URL to a Cosmos api node \"\"\" def __init__ ( self , * , api : str = \"https://api.cosmos.network\" ): self . _api = api def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: tx (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return [ hash , log ]","title":"HTTPClient"},{"location":"clients/httpclient/#mospy.clients.HTTPClient.HTTPClient.broadcast_transaction","text":"Sign and broadcast a transaction. Note Takes only positional arguments Parameters: Name Type Description Default tx Transaction The transaction object required timeout int Timeout 10 Returns: Name Type Description hash [ str , str ] Transaction hash log [ str , str ] Log (None if transaction successful) Source code in mospy\\clients\\HTTPClient.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: tx (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return [ hash , log ]","title":"broadcast_transaction()"},{"location":"clients/httpclient/#mospy.clients.HTTPClient.HTTPClient.load_account_data","text":"Load the next_sequence and account_number into the account object. Parameters: Name Type Description Default account Account Account required Source code in mospy\\clients\\HTTPClient.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number","title":"load_account_data()"}]}