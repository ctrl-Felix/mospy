{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MosPy MosPy is a cosmospy fork and aims to be a versatile transaction signing library for the whole cosmos ecosystem. Installation Mospy is available on pypi : python -m pip install mospy-wallet Note: Even though the name is mospy-wallet on pypi the library itself is called mospy Dependencies By default mospy will import the protobuf files from cosmospy-protobuf and therefore work with the Cosmos chain. If you want to use it on another chain I highly recommend to use thee according protobufs to avoid version conflicts. The Account and Transaction class both take a protobuf argument to specify the protobufs. Note: You have to install them manually as mospy ships woth cosmospy_protobuf. You can use: evmos for evmos-protobuf osmosis for osmosis-protobuf cosmos for cosmospy-protobuf (default) <your module here> for your own protobuf module following the cosmos name schema Get started import httpx # optional from mospy import Account, Transaction account = Account( seed_phrase=\"law grab theory better athlete submit awkward hawk state wedding wave monkey audit blame fury wood tag rent furnace exotic jeans drift destroy style\", address_index=12 ) tx = Transaction( account=account, gas=1000, ) tx.set_fee( amount=100, denom=\"uatom\" ) # Add a transfer message to the transaction (multiple messages can be added) tx.add_msg( tx_type='transfer', sender=account, receipient=\"cosmos1tkv9rquxr88r7snrg42kxdj9gsnfxxg028kuh9\", amount=1000, denom=\"uatom\" ) # Sign and encode transaction to submit it to the network manually # REST endpoint (RPC or API) tx_bytes = tx.get_tx_bytes_as_string() # Submit the transaction through the Tendermint RPC rpc_url = \"https://rpc.cosmos.network/\" pushable_tx = json.dumps( { \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"broadcast_tx_sync\", # Available methods: broadcast_tx_sync, broadcast_tx_async, broadcast_tx_commit \"params\": { \"tx\": tx_bytes } } ) r = httpx.post(rpc_url, data=pushable_tx) # Submit the transaction through the Cosmos REST API rpc_api = \"https://api.cosmos.network/cosmos/tx/v1beta1/txs\" pushable_tx = json.dumps( { \"tx_bytes\": tx_bytes, \"mode\": \"BROADCAST_MODE_SYNC\" # Available modes: BROADCAST_MODE_SYNC, BROADCAST_MODE_ASYNC, BROADCAST_MODE_BLOCK } ) r = httpx.post(rpc_api, data=pushable_tx) Support When facing issues feel free to open a github issue or reach out to the creators on the Osmosis Discord .","title":"Overview"},{"location":"#mospy","text":"MosPy is a cosmospy fork and aims to be a versatile transaction signing library for the whole cosmos ecosystem.","title":"MosPy"},{"location":"#installation","text":"Mospy is available on pypi : python -m pip install mospy-wallet Note: Even though the name is mospy-wallet on pypi the library itself is called mospy","title":"Installation"},{"location":"#dependencies","text":"By default mospy will import the protobuf files from cosmospy-protobuf and therefore work with the Cosmos chain. If you want to use it on another chain I highly recommend to use thee according protobufs to avoid version conflicts. The Account and Transaction class both take a protobuf argument to specify the protobufs. Note: You have to install them manually as mospy ships woth cosmospy_protobuf. You can use: evmos for evmos-protobuf osmosis for osmosis-protobuf cosmos for cosmospy-protobuf (default) <your module here> for your own protobuf module following the cosmos name schema","title":"Dependencies"},{"location":"#get-started","text":"import httpx # optional from mospy import Account, Transaction account = Account( seed_phrase=\"law grab theory better athlete submit awkward hawk state wedding wave monkey audit blame fury wood tag rent furnace exotic jeans drift destroy style\", address_index=12 ) tx = Transaction( account=account, gas=1000, ) tx.set_fee( amount=100, denom=\"uatom\" ) # Add a transfer message to the transaction (multiple messages can be added) tx.add_msg( tx_type='transfer', sender=account, receipient=\"cosmos1tkv9rquxr88r7snrg42kxdj9gsnfxxg028kuh9\", amount=1000, denom=\"uatom\" ) # Sign and encode transaction to submit it to the network manually # REST endpoint (RPC or API) tx_bytes = tx.get_tx_bytes_as_string() # Submit the transaction through the Tendermint RPC rpc_url = \"https://rpc.cosmos.network/\" pushable_tx = json.dumps( { \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"broadcast_tx_sync\", # Available methods: broadcast_tx_sync, broadcast_tx_async, broadcast_tx_commit \"params\": { \"tx\": tx_bytes } } ) r = httpx.post(rpc_url, data=pushable_tx) # Submit the transaction through the Cosmos REST API rpc_api = \"https://api.cosmos.network/cosmos/tx/v1beta1/txs\" pushable_tx = json.dumps( { \"tx_bytes\": tx_bytes, \"mode\": \"BROADCAST_MODE_SYNC\" # Available modes: BROADCAST_MODE_SYNC, BROADCAST_MODE_ASYNC, BROADCAST_MODE_BLOCK } ) r = httpx.post(rpc_api, data=pushable_tx)","title":"Get started"},{"location":"#support","text":"When facing issues feel free to open a github issue or reach out to the creators on the Osmosis Discord .","title":"Support"},{"location":"account/","text":"The account class can be instantiated through a seed or a private key. If nothing is provided it will create a new keyring and the params to work with the cosmos chain Note You can't provide a seed_phrase and a private_key A readble method behaves is the getter for a Attribute (Example: hrp = account.hrp ) A writable method is the setter for the Attribute (Example: account.hrp = \"cosmos\" ) A method can be setter and getter at the same time. The Parameters description always refers to the setter while the Returns section belongs to the getter Parameters: Name Type Description Default seed_phrase str Seed phrase to derive private keys from None private_key str Private key to instantiate the Account None next_sequence int Sequence which will be used for transactions signed with this Account None account_number int On-chain account number None slip44 int Slip44 value 118 hrp str Address Prefix 'cosmos' address_index int Address index to get sub accounts for seed phrases (doesn't work when using a private key) 0 protobuf str Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) 'cosmos' eth bool Etermint compatibility mpde. If set to true the addresses and signatures will match the ethereum standard. Defaults to false to match the Cosmos standard. False Source code in mospy/Account.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class Account : \"\"\" The account class can be instantiated through a seed or a private key. If nothing is provided it will create a new keyring and the params to work with the cosmos chain Note: * You can't provide a ``seed_phrase`` and a``private_key`` * A ``readble`` method behaves is the getter for a Attribute (Example: ``hrp = account.hrp``) * A ``writable`` method is the setter for the Attribute (Example: ``account.hrp = \"cosmos\"``) * A method can be setter and getter at the same time. The Parameters description always refers to the setter while the Returns section belongs to the getter Args: seed_phrase (str): Seed phrase to derive private keys from private_key (str): Private key to instantiate the Account next_sequence (int): Sequence which will be used for transactions signed with this Account account_number (int): On-chain account number slip44 (int): Slip44 value hrp (str): Address Prefix address_index (int): Address index to get sub accounts for seed phrases (doesn't work when using a private key) protobuf (str): Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) eth (bool): Etermint compatibility mpde. If set to true the addresses and signatures will match the ethereum standard. Defaults to false to match the Cosmos standard. \"\"\" address : str \"\"\"the address of the account derived by using the slip44 param, the hrp and the address_index\"\"\" _RAW_DERIVATION_PATH = \"m/44'/ {slip44} '/0'/0/ {address_index} \" def __init__ ( self , seed_phrase : str = None , private_key : str = None , next_sequence : int = None , account_number : int = None , slip44 : int = 118 , hrp : str = \"cosmos\" , address_index : int = 0 , protobuf : str = \"cosmos\" , eth : bool = False ): _protobuf_packages = { \"cosmos\" : \"cosmospy_protobuf\" , \"osmosis\" : \"osmosis_protobuf\" , \"evmos\" : \"evmos_protobuf\" , } _protobuf_package = ( _protobuf_packages [ protobuf . lower ()] if protobuf . lower () in _protobuf_packages . keys () else protobuf ) try : self . keys_pb2 = importlib . import_module ( _protobuf_package + \".cosmos.crypto.secp256k1.keys_pb2\" ) except AttributeError : raise ImportError ( \"It seems that you are importing conflicting protobuf files. Have sou set the protobuf attribute to specify your coin? Check out the documentation for more information.\" ) except : raise ImportError ( f \"Couldn't import from { _protobuf_package } . Is the package installed? \" ) self . _eth = eth self . _slip44 = slip44 self . _hrp = hrp self . _address_index = address_index self . _next_sequence = next_sequence self . _account_number = account_number if not seed_phrase and not private_key : self . _seed_phrase = Mnemonic ( language = \"english\" ) . generate ( strength = 256 ) self . _private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ()) elif seed_phrase and not private_key : self . _seed_phrase = seed_phrase self . _private_key = seed_to_private_key ( seed_phrase , self . _derivation_path ()) elif private_key and not seed_phrase : self . _seed_phrase = None self . _private_key = bytes . fromhex ( private_key ) else : raise AttributeError ( \"Please set only a private key or a seed phrase. Not both!\" ) def _derivation_path ( self , address_index : int = None ): adr_id = self . _address_index if not address_index else address_index params = { \"slip44\" : self . _slip44 , \"address_index\" : adr_id } return self . _RAW_DERIVATION_PATH . format ( ** params ) @property def address ( self ) -> str : \"\"\" Current address which depends on the hrp and the private key. Returns: Address \"\"\" if not self . _seed_phrase : address = privkey_to_address ( self . _private_key , hrp = self . _hrp ) if not self . _eth else privkey_to_eth_address ( self . _private_key , hrp = self . _hrp ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_address ( sub_private_key , hrp = self . _hrp ) if not self . _eth else privkey_to_eth_address ( sub_private_key , hrp = self . _hrp ) return address @property def eth_address ( self ) -> str : \"\"\" Ethereum compatible address starting with 0x. Only available if Account is initialised with eth set to True. Returns: Address \"\"\" if not self . _eth : raise TypeError ( \"Account hasn't been initialised with the eth mode set to true.\" ) if not self . _seed_phrase : address = privkey_to_eth_address ( self . _private_key ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_eth_address ( sub_private_key ) return address @property def seed_phrase ( self ) -> str : \"\"\" Current Seed Phrase Returns: Seed Phrase \"\"\" return self . _seed_phrase @property def private_key ( self ) -> bytes : \"\"\" Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Private Key \"\"\" if self . _seed_phrase : private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) return private_key else : return self . _private_key @property def public_key ( self ) -> str : \"\"\" Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Public Key \"\"\" pubkey_bytes = privkey_to_pubkey ( self . private_key ) _pubkey = self . keys_pb2 . PubKey () _pubkey . key = pubkey_bytes return _pubkey @property def account_number ( self ) -> int : \"\"\" On-chain account number which will be assigned when the address receives coins for the first time. Args: account_number (int): Account Number Returns: Account number \"\"\" return self . _account_number @account_number . setter def account_number ( self , account_number : int ): self . _account_number = account_number @property def next_sequence ( self ) -> int : \"\"\" Sequence which will be used for transactions signed with this Account. Args: next_sequence (int): Next sequence (only when used as setter) Returns: Next Sequence \"\"\" return self . _next_sequence @next_sequence . setter def next_sequence ( self , next_sequence ): self . _next_sequence = next_sequence def increase_sequence ( self , change : int = 1 ) -> None : \"\"\" Increase the sequence by ``change`` Args: change (int): Value to increase the sequence \"\"\" self . _next_sequence += change @property def address_index ( self ): \"\"\" Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Args: address_index (int): New address index Returns: Address Index \"\"\" return self . _address_index @address_index . setter def address_index ( self , address_index : int ) -> None : if self . _seed_phrase : self . _DEFAULT_ADDRESS_INDEX = address_index else : raise ValueError ( \"Can't the change the address index without provided seed\" ) @property def hrp ( self ) -> str : \"\"\" Current address prefix used by the Account. Args: hrp (str): New address prefix Returns: Address Prefix (hrp) \"\"\" return self . _hrp @hrp . setter def hrp ( self , hrp : str ) -> None : self . _hrp = hrp @property def slip44 ( self ) -> int : \"\"\"\" Set the Slip44 value. Cosmos defaults to 118 Args: slip44 (int): New slip44 value as defined in the [slip44 registry](https://github.com/satoshilabs/slips/blob/master/slip-0044.md) Returns: Slip44 \"\"\" return self . _slip44 @slip44 . setter def slip44 ( self , slip44 : int ) -> None : self . _slip44 = slip44 @property def eth ( self ) -> bool : \"\"\" Change the eth compatibility mode. If you want to use Evmos you will need to set eth to true. Otherwise it defaults to False Args: eth (bool): ETH compatibility mode Returns: eth \"\"\" return self . _eth @eth . setter def eth ( self , eth : bool ): self . _eth = eth account_number () property writable On-chain account number which will be assigned when the address receives coins for the first time. Parameters: Name Type Description Default account_number int Account Number required Returns: Type Description int Account number Source code in mospy/Account.py 184 185 186 187 188 189 190 191 192 193 194 @property def account_number ( self ) -> int : \"\"\" On-chain account number which will be assigned when the address receives coins for the first time. Args: account_number (int): Account Number Returns: Account number \"\"\" return self . _account_number address () property Current address which depends on the hrp and the private key. Returns: Type Description str Address Source code in mospy/Account.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @property def address ( self ) -> str : \"\"\" Current address which depends on the hrp and the private key. Returns: Address \"\"\" if not self . _seed_phrase : address = privkey_to_address ( self . _private_key , hrp = self . _hrp ) if not self . _eth else privkey_to_eth_address ( self . _private_key , hrp = self . _hrp ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_address ( sub_private_key , hrp = self . _hrp ) if not self . _eth else privkey_to_eth_address ( sub_private_key , hrp = self . _hrp ) return address address_index () property writable Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Parameters: Name Type Description Default address_index int New address index required Returns: Type Description Address Index Source code in mospy/Account.py 226 227 228 229 230 231 232 233 234 235 236 237 @property def address_index ( self ): \"\"\" Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Args: address_index (int): New address index Returns: Address Index \"\"\" return self . _address_index eth () property writable Change the eth compatibility mode. If you want to use Evmos you will need to set eth to true. Otherwise it defaults to False Parameters: Name Type Description Default eth bool ETH compatibility mode required Returns: Type Description bool eth Source code in mospy/Account.py 284 285 286 287 288 289 290 291 292 293 294 295 @property def eth ( self ) -> bool : \"\"\" Change the eth compatibility mode. If you want to use Evmos you will need to set eth to true. Otherwise it defaults to False Args: eth (bool): ETH compatibility mode Returns: eth \"\"\" return self . _eth eth_address () property Ethereum compatible address starting with 0x. Only available if Account is initialised with eth set to True. Returns: Type Description str Address Source code in mospy/Account.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 @property def eth_address ( self ) -> str : \"\"\" Ethereum compatible address starting with 0x. Only available if Account is initialised with eth set to True. Returns: Address \"\"\" if not self . _eth : raise TypeError ( \"Account hasn't been initialised with the eth mode set to true.\" ) if not self . _seed_phrase : address = privkey_to_eth_address ( self . _private_key ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_eth_address ( sub_private_key ) return address hrp () property writable Current address prefix used by the Account. Parameters: Name Type Description Default hrp str New address prefix required Returns: Type Description str Address Prefix (hrp) Source code in mospy/Account.py 248 249 250 251 252 253 254 255 256 257 258 259 260 @property def hrp ( self ) -> str : \"\"\" Current address prefix used by the Account. Args: hrp (str): New address prefix Returns: Address Prefix (hrp) \"\"\" return self . _hrp increase_sequence ( change = 1 ) Increase the sequence by change Parameters: Name Type Description Default change int Value to increase the sequence 1 Source code in mospy/Account.py 217 218 219 220 221 222 223 224 def increase_sequence ( self , change : int = 1 ) -> None : \"\"\" Increase the sequence by ``change`` Args: change (int): Value to increase the sequence \"\"\" self . _next_sequence += change next_sequence () property writable Sequence which will be used for transactions signed with this Account. Parameters: Name Type Description Default next_sequence int Next sequence (only when used as setter) required Returns: Type Description int Next Sequence Source code in mospy/Account.py 200 201 202 203 204 205 206 207 208 209 210 211 @property def next_sequence ( self ) -> int : \"\"\" Sequence which will be used for transactions signed with this Account. Args: next_sequence (int): Next sequence (only when used as setter) Returns: Next Sequence \"\"\" return self . _next_sequence private_key () property Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description bytes Private Key Source code in mospy/Account.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @property def private_key ( self ) -> bytes : \"\"\" Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Private Key \"\"\" if self . _seed_phrase : private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) return private_key else : return self . _private_key public_key () property Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description str Public Key Source code in mospy/Account.py 171 172 173 174 175 176 177 178 179 180 181 182 @property def public_key ( self ) -> str : \"\"\" Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Public Key \"\"\" pubkey_bytes = privkey_to_pubkey ( self . private_key ) _pubkey = self . keys_pb2 . PubKey () _pubkey . key = pubkey_bytes return _pubkey seed_phrase () property Current Seed Phrase Returns: Type Description str Seed Phrase Source code in mospy/Account.py 144 145 146 147 148 149 150 151 152 @property def seed_phrase ( self ) -> str : \"\"\" Current Seed Phrase Returns: Seed Phrase \"\"\" return self . _seed_phrase slip44 () property writable \" Set the Slip44 value. Cosmos defaults to 118 Parameters: Name Type Description Default slip44 int New slip44 value as defined in the slip44 registry required Returns: Type Description int Slip44 Source code in mospy/Account.py 266 267 268 269 270 271 272 273 274 275 276 277 278 @property def slip44 ( self ) -> int : \"\"\"\" Set the Slip44 value. Cosmos defaults to 118 Args: slip44 (int): New slip44 value as defined in the [slip44 registry](https://github.com/satoshilabs/slips/blob/master/slip-0044.md) Returns: Slip44 \"\"\" return self . _slip44","title":"Account"},{"location":"account/#mospy.Account.Account.account_number","text":"On-chain account number which will be assigned when the address receives coins for the first time. Parameters: Name Type Description Default account_number int Account Number required Returns: Type Description int Account number Source code in mospy/Account.py 184 185 186 187 188 189 190 191 192 193 194 @property def account_number ( self ) -> int : \"\"\" On-chain account number which will be assigned when the address receives coins for the first time. Args: account_number (int): Account Number Returns: Account number \"\"\" return self . _account_number","title":"account_number()"},{"location":"account/#mospy.Account.Account.address","text":"Current address which depends on the hrp and the private key. Returns: Type Description str Address Source code in mospy/Account.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @property def address ( self ) -> str : \"\"\" Current address which depends on the hrp and the private key. Returns: Address \"\"\" if not self . _seed_phrase : address = privkey_to_address ( self . _private_key , hrp = self . _hrp ) if not self . _eth else privkey_to_eth_address ( self . _private_key , hrp = self . _hrp ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_address ( sub_private_key , hrp = self . _hrp ) if not self . _eth else privkey_to_eth_address ( sub_private_key , hrp = self . _hrp ) return address","title":"address()"},{"location":"account/#mospy.Account.Account.address_index","text":"Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Parameters: Name Type Description Default address_index int New address index required Returns: Type Description Address Index Source code in mospy/Account.py 226 227 228 229 230 231 232 233 234 235 236 237 @property def address_index ( self ): \"\"\" Change the address index to use a sub account. This works only if a seed has been used to instantiate the Account. Args: address_index (int): New address index Returns: Address Index \"\"\" return self . _address_index","title":"address_index()"},{"location":"account/#mospy.Account.Account.eth","text":"Change the eth compatibility mode. If you want to use Evmos you will need to set eth to true. Otherwise it defaults to False Parameters: Name Type Description Default eth bool ETH compatibility mode required Returns: Type Description bool eth Source code in mospy/Account.py 284 285 286 287 288 289 290 291 292 293 294 295 @property def eth ( self ) -> bool : \"\"\" Change the eth compatibility mode. If you want to use Evmos you will need to set eth to true. Otherwise it defaults to False Args: eth (bool): ETH compatibility mode Returns: eth \"\"\" return self . _eth","title":"eth()"},{"location":"account/#mospy.Account.Account.eth_address","text":"Ethereum compatible address starting with 0x. Only available if Account is initialised with eth set to True. Returns: Type Description str Address Source code in mospy/Account.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 @property def eth_address ( self ) -> str : \"\"\" Ethereum compatible address starting with 0x. Only available if Account is initialised with eth set to True. Returns: Address \"\"\" if not self . _eth : raise TypeError ( \"Account hasn't been initialised with the eth mode set to true.\" ) if not self . _seed_phrase : address = privkey_to_eth_address ( self . _private_key ) else : sub_private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) address = privkey_to_eth_address ( sub_private_key ) return address","title":"eth_address()"},{"location":"account/#mospy.Account.Account.hrp","text":"Current address prefix used by the Account. Parameters: Name Type Description Default hrp str New address prefix required Returns: Type Description str Address Prefix (hrp) Source code in mospy/Account.py 248 249 250 251 252 253 254 255 256 257 258 259 260 @property def hrp ( self ) -> str : \"\"\" Current address prefix used by the Account. Args: hrp (str): New address prefix Returns: Address Prefix (hrp) \"\"\" return self . _hrp","title":"hrp()"},{"location":"account/#mospy.Account.Account.increase_sequence","text":"Increase the sequence by change Parameters: Name Type Description Default change int Value to increase the sequence 1 Source code in mospy/Account.py 217 218 219 220 221 222 223 224 def increase_sequence ( self , change : int = 1 ) -> None : \"\"\" Increase the sequence by ``change`` Args: change (int): Value to increase the sequence \"\"\" self . _next_sequence += change","title":"increase_sequence()"},{"location":"account/#mospy.Account.Account.next_sequence","text":"Sequence which will be used for transactions signed with this Account. Parameters: Name Type Description Default next_sequence int Next sequence (only when used as setter) required Returns: Type Description int Next Sequence Source code in mospy/Account.py 200 201 202 203 204 205 206 207 208 209 210 211 @property def next_sequence ( self ) -> int : \"\"\" Sequence which will be used for transactions signed with this Account. Args: next_sequence (int): Next sequence (only when used as setter) Returns: Next Sequence \"\"\" return self . _next_sequence","title":"next_sequence()"},{"location":"account/#mospy.Account.Account.private_key","text":"Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description bytes Private Key Source code in mospy/Account.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @property def private_key ( self ) -> bytes : \"\"\" Current private key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Private Key \"\"\" if self . _seed_phrase : private_key = seed_to_private_key ( self . _seed_phrase , self . _derivation_path ( address_index = self . _address_index ), ) return private_key else : return self . _private_key","title":"private_key()"},{"location":"account/#mospy.Account.Account.public_key","text":"Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Type Description str Public Key Source code in mospy/Account.py 171 172 173 174 175 176 177 178 179 180 181 182 @property def public_key ( self ) -> str : \"\"\" Current public key which depends on the slip 44 param and the address index if the account is instantiated through a seed. Returns: Public Key \"\"\" pubkey_bytes = privkey_to_pubkey ( self . private_key ) _pubkey = self . keys_pb2 . PubKey () _pubkey . key = pubkey_bytes return _pubkey","title":"public_key()"},{"location":"account/#mospy.Account.Account.seed_phrase","text":"Current Seed Phrase Returns: Type Description str Seed Phrase Source code in mospy/Account.py 144 145 146 147 148 149 150 151 152 @property def seed_phrase ( self ) -> str : \"\"\" Current Seed Phrase Returns: Seed Phrase \"\"\" return self . _seed_phrase","title":"seed_phrase()"},{"location":"account/#mospy.Account.Account.slip44","text":"\" Set the Slip44 value. Cosmos defaults to 118 Parameters: Name Type Description Default slip44 int New slip44 value as defined in the slip44 registry required Returns: Type Description int Slip44 Source code in mospy/Account.py 266 267 268 269 270 271 272 273 274 275 276 277 278 @property def slip44 ( self ) -> int : \"\"\"\" Set the Slip44 value. Cosmos defaults to 118 Args: slip44 (int): New slip44 value as defined in the [slip44 registry](https://github.com/satoshilabs/slips/blob/master/slip-0044.md) Returns: Slip44 \"\"\" return self . _slip44","title":"slip44()"},{"location":"examples/","text":"Examples Here you'll find some useful code snippets to get started with MosPy Account Examples showing the use of the account class Account creation from mospy import Account # Generate a new Account with a new seed phrase account1 = Account() # Create an account object through a seed phrase and # get a sub-account of that seed by passing the address index (optional) account2 = Account( seed_phrase=\"law grab theory better athlete submit awkward hawk state wedding wave monkey audit blame fury wood tag rent furnace exotic jeans drift destroy style\", address_index=12 ) # Instantiate the Account by using a private key and # set a different address prefix to use another cosmos based chain as well as # the nex account sequence and account number (example values) account3 = Account( private_key=\"8c2ae3f9c216f714c0a877e7a4952ec03462496e01452bd5ee79ef79d707ff6c\", hrp=\"osmo\", next_sequence=1, account_number=187486 ) Transaction Showcase how to create use the Transaction class from mospy import Transaction from cosmospy_protobuf.cosmos.base.v1beta1.coin_pb2 import Coin # Optional # Create the fee object from the protobufs and pass it when instantiating the Transaction # or add it later through the set_fee function fee = Coin( denom=\"uatom\", amount=\"1000\" ) # Create the transaction object by passing the account object from the step above tx = Transaction( account=account3, fee=fee, gas=1000, ) # Add a transfer message to the transaction (multiple messages can be added) tx.add_msg( tx_type='transfer', sender=account3, receipient=\"cosmos1tkv9rquxr88r7snrg42kxdj9gsnfxxg028kuh9\", amount=1000, denom=\"uatom\" ) # Sign and encode transaction to submit it to the network manually # REST endpoint (RPC or API) tx_bytes = tx.get_tx_bytes_as_string() # GRPC tx_bytes = tx.get_tx_bytes() Custom Transaction Message You can easily use every other tx type too. The type_url usually matches the import path. # References the tx class from above before signing from cosmospy_protobuf.cosmos.distribution.v1beta1.tx_pb2 import MsgSetWithdrawAddress wmsg = MsgSetWithdrawAddress( delegator_address=account.address, withdraw_address=\"newaddresshere\" ) tx.add_raw_msg(wmsg, type_url=\"/cosmos.distribution.v1beta1.MsgSetWithdrawAddress\") Client Examples howing the usage of the included clients from mospy.clients import HTTPClient # Instantiate a HTTPClient object by passing a custom API endpoint. # https://api.cosmos.network is chosen if no api provider is provided client = HTTPClient( api=\"https://api.cosmos.interbloc.org\" ) # Update the account object to set the current on chain sequence and account_number client.load_account_data(account=account) # Broadcast a transaction # Note: Do not call 'get_tx_bytes' on the transaction object before # as it will be signed twice then hash, code, log = client.broadcast_transaction(transaction=tx) Ethereum/Ethermint Transaction Make a transaction on chains using Ethermint like Evmos from mospy import Transaction from mospy.clients import HTTPClient from src.mospy import Account # As the account query returns a different json than the standard cosmos one evmos won't be compatible with the # client.load_account() function account = Account( seed_phrase=\"law grab theory better athlete submit awkward hawk state wedding wave monkey audit blame fury wood tag rent furnace exotic jeans drift destroy style\", hrp=\"evmos\", slip44=60, eth=True, next_sequence=1, account_number=2154050, ) tx = Transaction( account=account, gas=2000000, memo=\"The first mospy evmos transaction!\", chain_id=\"evmos_9001-2\", ) tx.set_fee( denom=\"aevmos\", amount=40000000000000000 ) tx.add_msg( tx_type=\"transfer\", sender=account, receipient=account.address, amount=3500000000000000, denom=\"aevmos\", ) client = HTTPClient(api=\"https://api.evmos.interbloc.org\") tx_response = client.broadcast_transaction(transaction=tx)","title":"Examples"},{"location":"examples/#examples","text":"Here you'll find some useful code snippets to get started with MosPy","title":"Examples"},{"location":"examples/#account","text":"Examples showing the use of the account class","title":"Account"},{"location":"examples/#account-creation","text":"from mospy import Account # Generate a new Account with a new seed phrase account1 = Account() # Create an account object through a seed phrase and # get a sub-account of that seed by passing the address index (optional) account2 = Account( seed_phrase=\"law grab theory better athlete submit awkward hawk state wedding wave monkey audit blame fury wood tag rent furnace exotic jeans drift destroy style\", address_index=12 ) # Instantiate the Account by using a private key and # set a different address prefix to use another cosmos based chain as well as # the nex account sequence and account number (example values) account3 = Account( private_key=\"8c2ae3f9c216f714c0a877e7a4952ec03462496e01452bd5ee79ef79d707ff6c\", hrp=\"osmo\", next_sequence=1, account_number=187486 )","title":"Account creation"},{"location":"examples/#transaction","text":"Showcase how to create use the Transaction class from mospy import Transaction from cosmospy_protobuf.cosmos.base.v1beta1.coin_pb2 import Coin # Optional # Create the fee object from the protobufs and pass it when instantiating the Transaction # or add it later through the set_fee function fee = Coin( denom=\"uatom\", amount=\"1000\" ) # Create the transaction object by passing the account object from the step above tx = Transaction( account=account3, fee=fee, gas=1000, ) # Add a transfer message to the transaction (multiple messages can be added) tx.add_msg( tx_type='transfer', sender=account3, receipient=\"cosmos1tkv9rquxr88r7snrg42kxdj9gsnfxxg028kuh9\", amount=1000, denom=\"uatom\" ) # Sign and encode transaction to submit it to the network manually # REST endpoint (RPC or API) tx_bytes = tx.get_tx_bytes_as_string() # GRPC tx_bytes = tx.get_tx_bytes()","title":"Transaction"},{"location":"examples/#custom-transaction-message","text":"You can easily use every other tx type too. The type_url usually matches the import path. # References the tx class from above before signing from cosmospy_protobuf.cosmos.distribution.v1beta1.tx_pb2 import MsgSetWithdrawAddress wmsg = MsgSetWithdrawAddress( delegator_address=account.address, withdraw_address=\"newaddresshere\" ) tx.add_raw_msg(wmsg, type_url=\"/cosmos.distribution.v1beta1.MsgSetWithdrawAddress\")","title":"Custom Transaction Message"},{"location":"examples/#client","text":"Examples howing the usage of the included clients from mospy.clients import HTTPClient # Instantiate a HTTPClient object by passing a custom API endpoint. # https://api.cosmos.network is chosen if no api provider is provided client = HTTPClient( api=\"https://api.cosmos.interbloc.org\" ) # Update the account object to set the current on chain sequence and account_number client.load_account_data(account=account) # Broadcast a transaction # Note: Do not call 'get_tx_bytes' on the transaction object before # as it will be signed twice then hash, code, log = client.broadcast_transaction(transaction=tx)","title":"Client"},{"location":"examples/#ethereumethermint-transaction","text":"Make a transaction on chains using Ethermint like Evmos from mospy import Transaction from mospy.clients import HTTPClient from src.mospy import Account # As the account query returns a different json than the standard cosmos one evmos won't be compatible with the # client.load_account() function account = Account( seed_phrase=\"law grab theory better athlete submit awkward hawk state wedding wave monkey audit blame fury wood tag rent furnace exotic jeans drift destroy style\", hrp=\"evmos\", slip44=60, eth=True, next_sequence=1, account_number=2154050, ) tx = Transaction( account=account, gas=2000000, memo=\"The first mospy evmos transaction!\", chain_id=\"evmos_9001-2\", ) tx.set_fee( denom=\"aevmos\", amount=40000000000000000 ) tx.add_msg( tx_type=\"transfer\", sender=account, receipient=account.address, amount=3500000000000000, denom=\"aevmos\", ) client = HTTPClient(api=\"https://api.evmos.interbloc.org\") tx_response = client.broadcast_transaction(transaction=tx)","title":"Ethereum/Ethermint Transaction"},{"location":"transaction/","text":"Class to create and sign a transaction Parameters: Name Type Description Default account Account Account object to sign this transaction required gas int Gas unit for this transaction required fee coin The fee to pay for this transaction (This can also be added later through the set_fee method) None memo str Memo '' chain_id str Chain-Id \"cosmoshub-4\", 'cosmoshub-4' protobuf str Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) 'cosmos' Source code in mospy/Transaction.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Transaction : \"\"\"Class to create and sign a transaction Args: account (Account): Account object to sign this transaction gas (int): Gas unit for this transaction fee (coin): The fee to pay for this transaction (This can also be added later through the ``set_fee`` method) memo (str): Memo chain_id (str): Chain-Id \"cosmoshub-4\", protobuf (str): Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) \"\"\" def __init__ ( self , * , account : Account , gas : int , fee : object = None , memo : str = \"\" , chain_id : str = \"cosmoshub-4\" , protobuf : str = \"cosmos\" , ) -> None : _protobuf_packages = { \"cosmos\" : \"cosmospy_protobuf\" , \"osmosis\" : \"osmosis_protobuf\" , \"evmos\" : \"evmos_protobuf\" , } self . _protobuf_package = ( _protobuf_packages [ protobuf . lower ()] if protobuf . lower () in _protobuf_packages . keys () else protobuf ) try : self . coin_pb2 = importlib . import_module ( self . _protobuf_package + \".cosmos.base.v1beta1.coin_pb2\" ) self . tx_pb2 = importlib . import_module ( self . _protobuf_package + \".cosmos.tx.v1beta1.tx_pb2\" ) except : raise ImportError ( f \"Couldn't import from { self . _protobuf_package } . Is the package installed?\" ) if fee and not isinstance ( fee , ( self . coin_pb2 . Coin )): raise ValueError ( \"The fee is not a valid.\" ) self . _account = account self . _fee = fee self . _gas = gas self . _chain_id = chain_id self . _tx_body = self . tx_pb2 . TxBody () self . _tx_body . memo = memo self . _tx_raw = self . tx_pb2 . TxRaw () def add_msg ( self , tx_type : str , ** kwargs ) -> None : \"\"\" Add a pre-defined message to the tx body. Args: tx_type (str): Transaction type to match the transaction with the pre-defined ones **kwargs: Depending on the transaction type \"\"\" msg_data = built_in_transactions [ tx_type ]( protobuf_package = self . _protobuf_package , ** kwargs ) . format () self . add_raw_msg ( msg_data [ 1 ], type_url = msg_data [ 0 ]) def add_raw_msg ( self , unpacked_msg , type_url : str ) -> None : \"\"\" Add a message to the tx body manually. Args: unpacked_msg: Transaction data type_url: Type url for the transaction \"\"\" msg_any = any . Any () msg_any . Pack ( unpacked_msg ) msg_any . type_url = type_url self . _tx_body . messages . append ( msg_any ) def set_fee ( self , amount : int , denom : str = \"uatom\" ): \"\"\" Set the fee manually Args: amount: Amount denom: Denom \"\"\" self . _fee = self . coin_pb2 . Coin ( amount = str ( amount ), denom = denom ) def get_tx_bytes ( self ) -> bytes : \"\"\"Sign the transaction and get the tx bytes which can be used to broadcast the transaction to the network. To broadcast the transaction through the REST endpoint use the ``get_tx_bytes_as_string()`` method instead Returns: tx_bytes (bytes): Transaction bytes \"\"\" self . _tx_raw . body_bytes = self . _tx_body . SerializeToString () self . _tx_raw . auth_info_bytes = self . _get_auth_info () . SerializeToString ( ) self . _tx_raw . signatures . append ( self . _get_signatures ()) raw_tx = self . _tx_raw . SerializeToString () tx_bytes = bytes ( raw_tx ) return tx_bytes def get_tx_bytes_as_string ( self ) -> str : \"\"\"Sign the transaction and get the base64 encoded tx bytes which can be used to broadcast the transaction to the network. Returns: tx_bytes (str): Transaction bytes \"\"\" tx_bytes = self . get_tx_bytes () tx_b64 = base64 . b64encode ( tx_bytes ) . decode ( \"utf-8\" ) return tx_b64 def _get_signatures ( self ): privkey = ecdsa . SigningKey . from_string ( self . _account . private_key , curve = ecdsa . SECP256k1 ) # Cosmos uses sha256 as main hashing function while ethereum uses keccak256 hashfunc = hashlib . sha256 if not self . _account . eth else keccak_256 signature_compact = privkey . sign_deterministic ( self . _get_sign_doc () . SerializeToString (), hashfunc = hashfunc , sigencode = ecdsa . util . sigencode_string_canonize , ) return signature_compact def _get_sign_doc ( self ): sign_doc = self . tx_pb2 . SignDoc () sign_doc . body_bytes = self . _tx_body . SerializeToString () sign_doc . auth_info_bytes = self . _get_auth_info () . SerializeToString () sign_doc . chain_id = self . _chain_id sign_doc . account_number = self . _account . account_number return sign_doc def _get_auth_info ( self ): _auth_info = self . tx_pb2 . AuthInfo () _auth_info . signer_infos . append ( self . _get_signer_infos ()) _auth_info . fee . gas_limit = self . _gas _auth_info . fee . amount . append ( self . _fee ) return _auth_info def _get_signer_infos ( self ): signer_infos = self . tx_pb2 . SignerInfo () signer_infos . sequence = self . _account . next_sequence signer_infos . public_key . Pack ( self . _account . public_key ) if self . _account . eth : signer_infos . public_key . type_url = \"/ethermint.crypto.v1.ethsecp256k1.PubKey\" else : signer_infos . public_key . type_url = \"/cosmos.crypto.secp256k1.PubKey\" signer_infos . mode_info . single . mode = 1 return signer_infos add_msg ( tx_type , ** kwargs ) Add a pre-defined message to the tx body. Parameters: Name Type Description Default tx_type str Transaction type to match the transaction with the pre-defined ones required **kwargs Depending on the transaction type {} Source code in mospy/Transaction.py 72 73 74 75 76 77 78 79 80 81 82 def add_msg ( self , tx_type : str , ** kwargs ) -> None : \"\"\" Add a pre-defined message to the tx body. Args: tx_type (str): Transaction type to match the transaction with the pre-defined ones **kwargs: Depending on the transaction type \"\"\" msg_data = built_in_transactions [ tx_type ]( protobuf_package = self . _protobuf_package , ** kwargs ) . format () self . add_raw_msg ( msg_data [ 1 ], type_url = msg_data [ 0 ]) add_raw_msg ( unpacked_msg , type_url ) Add a message to the tx body manually. Parameters: Name Type Description Default unpacked_msg Transaction data required type_url str Type url for the transaction required Source code in mospy/Transaction.py 84 85 86 87 88 89 90 91 92 93 94 95 def add_raw_msg ( self , unpacked_msg , type_url : str ) -> None : \"\"\" Add a message to the tx body manually. Args: unpacked_msg: Transaction data type_url: Type url for the transaction \"\"\" msg_any = any . Any () msg_any . Pack ( unpacked_msg ) msg_any . type_url = type_url self . _tx_body . messages . append ( msg_any ) get_tx_bytes () Sign the transaction and get the tx bytes which can be used to broadcast the transaction to the network. To broadcast the transaction through the REST endpoint use the get_tx_bytes_as_string() method instead Returns: Name Type Description tx_bytes bytes Transaction bytes Source code in mospy/Transaction.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def get_tx_bytes ( self ) -> bytes : \"\"\"Sign the transaction and get the tx bytes which can be used to broadcast the transaction to the network. To broadcast the transaction through the REST endpoint use the ``get_tx_bytes_as_string()`` method instead Returns: tx_bytes (bytes): Transaction bytes \"\"\" self . _tx_raw . body_bytes = self . _tx_body . SerializeToString () self . _tx_raw . auth_info_bytes = self . _get_auth_info () . SerializeToString ( ) self . _tx_raw . signatures . append ( self . _get_signatures ()) raw_tx = self . _tx_raw . SerializeToString () tx_bytes = bytes ( raw_tx ) return tx_bytes get_tx_bytes_as_string () Sign the transaction and get the base64 encoded tx bytes which can be used to broadcast the transaction to the network. Returns: Name Type Description tx_bytes str Transaction bytes Source code in mospy/Transaction.py 123 124 125 126 127 128 129 130 131 def get_tx_bytes_as_string ( self ) -> str : \"\"\"Sign the transaction and get the base64 encoded tx bytes which can be used to broadcast the transaction to the network. Returns: tx_bytes (str): Transaction bytes \"\"\" tx_bytes = self . get_tx_bytes () tx_b64 = base64 . b64encode ( tx_bytes ) . decode ( \"utf-8\" ) return tx_b64 set_fee ( amount , denom = 'uatom' ) Set the fee manually Parameters: Name Type Description Default amount int Amount required denom str Denom 'uatom' Source code in mospy/Transaction.py 97 98 99 100 101 102 103 104 105 def set_fee ( self , amount : int , denom : str = \"uatom\" ): \"\"\" Set the fee manually Args: amount: Amount denom: Denom \"\"\" self . _fee = self . coin_pb2 . Coin ( amount = str ( amount ), denom = denom )","title":"Transaction"},{"location":"transaction/#mospy.Transaction.Transaction.add_msg","text":"Add a pre-defined message to the tx body. Parameters: Name Type Description Default tx_type str Transaction type to match the transaction with the pre-defined ones required **kwargs Depending on the transaction type {} Source code in mospy/Transaction.py 72 73 74 75 76 77 78 79 80 81 82 def add_msg ( self , tx_type : str , ** kwargs ) -> None : \"\"\" Add a pre-defined message to the tx body. Args: tx_type (str): Transaction type to match the transaction with the pre-defined ones **kwargs: Depending on the transaction type \"\"\" msg_data = built_in_transactions [ tx_type ]( protobuf_package = self . _protobuf_package , ** kwargs ) . format () self . add_raw_msg ( msg_data [ 1 ], type_url = msg_data [ 0 ])","title":"add_msg()"},{"location":"transaction/#mospy.Transaction.Transaction.add_raw_msg","text":"Add a message to the tx body manually. Parameters: Name Type Description Default unpacked_msg Transaction data required type_url str Type url for the transaction required Source code in mospy/Transaction.py 84 85 86 87 88 89 90 91 92 93 94 95 def add_raw_msg ( self , unpacked_msg , type_url : str ) -> None : \"\"\" Add a message to the tx body manually. Args: unpacked_msg: Transaction data type_url: Type url for the transaction \"\"\" msg_any = any . Any () msg_any . Pack ( unpacked_msg ) msg_any . type_url = type_url self . _tx_body . messages . append ( msg_any )","title":"add_raw_msg()"},{"location":"transaction/#mospy.Transaction.Transaction.get_tx_bytes","text":"Sign the transaction and get the tx bytes which can be used to broadcast the transaction to the network. To broadcast the transaction through the REST endpoint use the get_tx_bytes_as_string() method instead Returns: Name Type Description tx_bytes bytes Transaction bytes Source code in mospy/Transaction.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def get_tx_bytes ( self ) -> bytes : \"\"\"Sign the transaction and get the tx bytes which can be used to broadcast the transaction to the network. To broadcast the transaction through the REST endpoint use the ``get_tx_bytes_as_string()`` method instead Returns: tx_bytes (bytes): Transaction bytes \"\"\" self . _tx_raw . body_bytes = self . _tx_body . SerializeToString () self . _tx_raw . auth_info_bytes = self . _get_auth_info () . SerializeToString ( ) self . _tx_raw . signatures . append ( self . _get_signatures ()) raw_tx = self . _tx_raw . SerializeToString () tx_bytes = bytes ( raw_tx ) return tx_bytes","title":"get_tx_bytes()"},{"location":"transaction/#mospy.Transaction.Transaction.get_tx_bytes_as_string","text":"Sign the transaction and get the base64 encoded tx bytes which can be used to broadcast the transaction to the network. Returns: Name Type Description tx_bytes str Transaction bytes Source code in mospy/Transaction.py 123 124 125 126 127 128 129 130 131 def get_tx_bytes_as_string ( self ) -> str : \"\"\"Sign the transaction and get the base64 encoded tx bytes which can be used to broadcast the transaction to the network. Returns: tx_bytes (str): Transaction bytes \"\"\" tx_bytes = self . get_tx_bytes () tx_b64 = base64 . b64encode ( tx_bytes ) . decode ( \"utf-8\" ) return tx_b64","title":"get_tx_bytes_as_string()"},{"location":"transaction/#mospy.Transaction.Transaction.set_fee","text":"Set the fee manually Parameters: Name Type Description Default amount int Amount required denom str Denom 'uatom' Source code in mospy/Transaction.py 97 98 99 100 101 102 103 104 105 def set_fee ( self , amount : int , denom : str = \"uatom\" ): \"\"\" Set the fee manually Args: amount: Amount denom: Denom \"\"\" self . _fee = self . coin_pb2 . Coin ( amount = str ( amount ), denom = denom )","title":"set_fee()"},{"location":"clients/","text":"Clients The client classes contain helper functions supporting you while interacting with the chain. Supported Endpoints API: HTTPClient GRPC: GRPCClient","title":"Clients"},{"location":"clients/#clients","text":"The client classes contain helper functions supporting you while interacting with the chain.","title":"Clients"},{"location":"clients/#supported-endpoints","text":"API: HTTPClient GRPC: GRPCClient","title":"Supported Endpoints"},{"location":"clients/grpcclient/","text":"HTTPClient Wrapper class to interact with a cosmos chain through their grpc endpoint Parameters: Name Type Description Default host str URL to a Cosmos api node 'cosmoshub.strange.love' port int Port to connect to 9090 ssl bool Whether a ssl encrypted endpoint should be used False protobuf str Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) 'cosmos' Source code in mospy/clients/GRPCClient.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 class GRPCClient : \"\"\" Wrapper class to interact with a cosmos chain through their grpc endpoint Args: host (str): URL to a Cosmos api node port (int): Port to connect to ssl (bool): Whether a ssl encrypted endpoint should be used protobuf (str): Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) \"\"\" def __init__ ( self , * , host : str = \"cosmoshub.strange.love\" , port : int = 9090 , ssl : bool = False , protobuf = \"cosmos\" , ): _protobuf_packages = { \"cosmos\" : \"cosmospy_protobuf\" , \"osmosis\" : \"osmosis_protobuf\" , \"evmos\" : \"evmos_protobuf\" , } _protobuf_package = ( _protobuf_packages [ protobuf . lower ()] if protobuf . lower () in _protobuf_packages . keys () else protobuf ) try : self . BroadcastTxRequest = importlib . import_module ( _protobuf_package + \".cosmos.tx.v1beta1.service_pb2\" ) . BroadcastTxRequest self . query_pb2 = importlib . import_module ( _protobuf_package + \".cosmos.auth.v1beta1.query_pb2\" ) self . query_pb2_grpc = importlib . import_module ( _protobuf_package + \".cosmos.auth.v1beta1.query_pb2_grpc\" ) self . service_pb2_grpc = importlib . import_module ( _protobuf_package + \".cosmos.tx.v1beta1.service_pb2_grpc\" ) except AttributeError : raise ImportError ( \"It seems that you are importing conflicting protobuf files. Have sou set the protobuf attribute to specify your coin? Check out the documentation for more information.\" ) except : raise ImportError ( f \"Couldn't import from { _protobuf_package } . Is the package installed? \" ) self . _host = host self . _port = port self . _ssl = ssl def _connect ( self ): if self . _ssl : con = grpc . secure_channel ( f \" { self . _host } : { self . _port } \" , credentials = grpc . ssl_channel_credentials ()) else : con = grpc . insecure_channel ( f \" { self . _host } : { self . _port } \" ) return con def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" con = self . _connect () address = account . address query_stub = self . query_pb2_grpc . QueryStub ( con ) account_request = self . query_pb2 . QueryAccountRequest ( address = address ) req = query_stub . Account ( account_request ) data = dict ( MessageToDict ( req . account )) sequence = 0 if not \"sequence\" in data else int ( data [ \"sequence\" ]) account_number = int ( data [ \"accountNumber\" ]) account . next_sequence = sequence account . account_number = account_number con . close () def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" con = self . _connect () tx_bytes = transaction . get_tx_bytes () tx_request = self . BroadcastTxRequest ( tx_bytes = tx_bytes , mode = 2 # BROADCAST_MODE_SYNC ) tx_stub = self . service_pb2_grpc . ServiceStub ( con ) tx_data = tx_stub . BroadcastTx ( tx_request ) hash = tx_data . tx_response . txhash code = tx_data . tx_response . code log = None if code == 0 else tx_data . tx_response . raw_log return { \"hash\" : hash , \"code\" : code , \"log\" : log } broadcast_transaction ( * , transaction , timeout = 10 ) Sign and broadcast a transaction. Note Takes only positional arguments Parameters: Name Type Description Default transaction Transaction The transaction object required Returns: Name Type Description hash [ str , int , str ] Transaction hash code [ str , int , str ] Result code log [ str , int , str ] Log (None if transaction successful) Source code in mospy/clients/GRPCClient.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" con = self . _connect () tx_bytes = transaction . get_tx_bytes () tx_request = self . BroadcastTxRequest ( tx_bytes = tx_bytes , mode = 2 # BROADCAST_MODE_SYNC ) tx_stub = self . service_pb2_grpc . ServiceStub ( con ) tx_data = tx_stub . BroadcastTx ( tx_request ) hash = tx_data . tx_response . txhash code = tx_data . tx_response . code log = None if code == 0 else tx_data . tx_response . raw_log return { \"hash\" : hash , \"code\" : code , \"log\" : log } load_account_data ( account ) Load the next_sequence and account_number into the account object. Parameters: Name Type Description Default account Account Account required Source code in mospy/clients/GRPCClient.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" con = self . _connect () address = account . address query_stub = self . query_pb2_grpc . QueryStub ( con ) account_request = self . query_pb2 . QueryAccountRequest ( address = address ) req = query_stub . Account ( account_request ) data = dict ( MessageToDict ( req . account )) sequence = 0 if not \"sequence\" in data else int ( data [ \"sequence\" ]) account_number = int ( data [ \"accountNumber\" ]) account . next_sequence = sequence account . account_number = account_number con . close ()","title":"Grpcclient"},{"location":"clients/grpcclient/#httpclient","text":"Wrapper class to interact with a cosmos chain through their grpc endpoint Parameters: Name Type Description Default host str URL to a Cosmos api node 'cosmoshub.strange.love' port int Port to connect to 9090 ssl bool Whether a ssl encrypted endpoint should be used False protobuf str Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) 'cosmos' Source code in mospy/clients/GRPCClient.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 class GRPCClient : \"\"\" Wrapper class to interact with a cosmos chain through their grpc endpoint Args: host (str): URL to a Cosmos api node port (int): Port to connect to ssl (bool): Whether a ssl encrypted endpoint should be used protobuf (str): Define which protobuf files to use. Cosmos, Evmos and Osmosis are built in and otherwise pass the raw package name (cosmospy-protobuf) \"\"\" def __init__ ( self , * , host : str = \"cosmoshub.strange.love\" , port : int = 9090 , ssl : bool = False , protobuf = \"cosmos\" , ): _protobuf_packages = { \"cosmos\" : \"cosmospy_protobuf\" , \"osmosis\" : \"osmosis_protobuf\" , \"evmos\" : \"evmos_protobuf\" , } _protobuf_package = ( _protobuf_packages [ protobuf . lower ()] if protobuf . lower () in _protobuf_packages . keys () else protobuf ) try : self . BroadcastTxRequest = importlib . import_module ( _protobuf_package + \".cosmos.tx.v1beta1.service_pb2\" ) . BroadcastTxRequest self . query_pb2 = importlib . import_module ( _protobuf_package + \".cosmos.auth.v1beta1.query_pb2\" ) self . query_pb2_grpc = importlib . import_module ( _protobuf_package + \".cosmos.auth.v1beta1.query_pb2_grpc\" ) self . service_pb2_grpc = importlib . import_module ( _protobuf_package + \".cosmos.tx.v1beta1.service_pb2_grpc\" ) except AttributeError : raise ImportError ( \"It seems that you are importing conflicting protobuf files. Have sou set the protobuf attribute to specify your coin? Check out the documentation for more information.\" ) except : raise ImportError ( f \"Couldn't import from { _protobuf_package } . Is the package installed? \" ) self . _host = host self . _port = port self . _ssl = ssl def _connect ( self ): if self . _ssl : con = grpc . secure_channel ( f \" { self . _host } : { self . _port } \" , credentials = grpc . ssl_channel_credentials ()) else : con = grpc . insecure_channel ( f \" { self . _host } : { self . _port } \" ) return con def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" con = self . _connect () address = account . address query_stub = self . query_pb2_grpc . QueryStub ( con ) account_request = self . query_pb2 . QueryAccountRequest ( address = address ) req = query_stub . Account ( account_request ) data = dict ( MessageToDict ( req . account )) sequence = 0 if not \"sequence\" in data else int ( data [ \"sequence\" ]) account_number = int ( data [ \"accountNumber\" ]) account . next_sequence = sequence account . account_number = account_number con . close () def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" con = self . _connect () tx_bytes = transaction . get_tx_bytes () tx_request = self . BroadcastTxRequest ( tx_bytes = tx_bytes , mode = 2 # BROADCAST_MODE_SYNC ) tx_stub = self . service_pb2_grpc . ServiceStub ( con ) tx_data = tx_stub . BroadcastTx ( tx_request ) hash = tx_data . tx_response . txhash code = tx_data . tx_response . code log = None if code == 0 else tx_data . tx_response . raw_log return { \"hash\" : hash , \"code\" : code , \"log\" : log }","title":"HTTPClient"},{"location":"clients/grpcclient/#mospy.clients.GRPCClient.GRPCClient.broadcast_transaction","text":"Sign and broadcast a transaction. Note Takes only positional arguments Parameters: Name Type Description Default transaction Transaction The transaction object required Returns: Name Type Description hash [ str , int , str ] Transaction hash code [ str , int , str ] Result code log [ str , int , str ] Log (None if transaction successful) Source code in mospy/clients/GRPCClient.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" con = self . _connect () tx_bytes = transaction . get_tx_bytes () tx_request = self . BroadcastTxRequest ( tx_bytes = tx_bytes , mode = 2 # BROADCAST_MODE_SYNC ) tx_stub = self . service_pb2_grpc . ServiceStub ( con ) tx_data = tx_stub . BroadcastTx ( tx_request ) hash = tx_data . tx_response . txhash code = tx_data . tx_response . code log = None if code == 0 else tx_data . tx_response . raw_log return { \"hash\" : hash , \"code\" : code , \"log\" : log }","title":"broadcast_transaction()"},{"location":"clients/grpcclient/#mospy.clients.GRPCClient.GRPCClient.load_account_data","text":"Load the next_sequence and account_number into the account object. Parameters: Name Type Description Default account Account Account required Source code in mospy/clients/GRPCClient.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" con = self . _connect () address = account . address query_stub = self . query_pb2_grpc . QueryStub ( con ) account_request = self . query_pb2 . QueryAccountRequest ( address = address ) req = query_stub . Account ( account_request ) data = dict ( MessageToDict ( req . account )) sequence = 0 if not \"sequence\" in data else int ( data [ \"sequence\" ]) account_number = int ( data [ \"accountNumber\" ]) account . next_sequence = sequence account . account_number = account_number con . close ()","title":"load_account_data()"},{"location":"clients/httpclient/","text":"HTTPClient Wrapper class to interact with a cosmos chain through their API endpoint Parameters: Name Type Description Default api str URL to a Api node 'https://api.cosmos.interbloc.org' Source code in mospy/clients/HTTPClient.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class HTTPClient : \"\"\" Wrapper class to interact with a cosmos chain through their API endpoint Args: api (str): URL to a Api node \"\"\" def __init__ ( self , * , api : str = \"https://api.cosmos.interbloc.org\" ): self . _api = api def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes_as_string () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return { \"hash\" : hash , \"code\" : code , \"log\" : log } broadcast_transaction ( * , transaction , timeout = 10 ) Sign and broadcast a transaction. Note Takes only positional arguments Parameters: Name Type Description Default transaction Transaction The transaction object required timeout int Timeout 10 Returns: Name Type Description hash [ str , int , str ] Transaction hash code [ str , int , str ] Result code log [ str , int , str ] Log (None if transaction successful) Source code in mospy/clients/HTTPClient.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes_as_string () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return { \"hash\" : hash , \"code\" : code , \"log\" : log } load_account_data ( account ) Load the next_sequence and account_number into the account object. Parameters: Name Type Description Default account Account Account required Source code in mospy/clients/HTTPClient.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number","title":"Httpclient"},{"location":"clients/httpclient/#httpclient","text":"Wrapper class to interact with a cosmos chain through their API endpoint Parameters: Name Type Description Default api str URL to a Api node 'https://api.cosmos.interbloc.org' Source code in mospy/clients/HTTPClient.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class HTTPClient : \"\"\" Wrapper class to interact with a cosmos chain through their API endpoint Args: api (str): URL to a Api node \"\"\" def __init__ ( self , * , api : str = \"https://api.cosmos.interbloc.org\" ): self . _api = api def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes_as_string () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return { \"hash\" : hash , \"code\" : code , \"log\" : log }","title":"HTTPClient"},{"location":"clients/httpclient/#mospy.clients.HTTPClient.HTTPClient.broadcast_transaction","text":"Sign and broadcast a transaction. Note Takes only positional arguments Parameters: Name Type Description Default transaction Transaction The transaction object required timeout int Timeout 10 Returns: Name Type Description hash [ str , int , str ] Transaction hash code [ str , int , str ] Result code log [ str , int , str ] Log (None if transaction successful) Source code in mospy/clients/HTTPClient.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def broadcast_transaction ( self , * , transaction : Transaction , timeout : int = 10 ) -> [ str , int , str ]: \"\"\" Sign and broadcast a transaction. Note: Takes only positional arguments Args: transaction (Transaction): The transaction object timeout (int): Timeout Returns: hash: Transaction hash code: Result code log: Log (None if transaction successful) \"\"\" url = self . _api + \"/cosmos/tx/v1beta1/txs\" tx_bytes = transaction . get_tx_bytes_as_string () pushable_tx = { \"tx_bytes\" : tx_bytes , \"mode\" : \"BROADCAST_MODE_SYNC\" } req = httpx . post ( url , json = pushable_tx , timeout = timeout ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () hash = data [ \"tx_response\" ][ \"txhash\" ] code = data [ \"tx_response\" ][ \"code\" ] log = None if code == 0 else data [ \"tx_response\" ][ \"raw_log\" ] return { \"hash\" : hash , \"code\" : code , \"log\" : log }","title":"broadcast_transaction()"},{"location":"clients/httpclient/#mospy.clients.HTTPClient.HTTPClient.load_account_data","text":"Load the next_sequence and account_number into the account object. Parameters: Name Type Description Default account Account Account required Source code in mospy/clients/HTTPClient.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def load_account_data ( self , account : Account ): \"\"\" Load the ``next_sequence`` and ``account_number`` into the account object. Args: account (Account): Account \"\"\" address = account . address url = self . _api + \"/cosmos/auth/v1beta1/accounts/\" + address req = httpx . get ( url = url ) if req . status_code != 200 : raise RuntimeError ( \"Error while doing request to api endpoint\" ) data = req . json () sequence = int ( data [ \"account\" ][ \"sequence\" ]) account_number = int ( data [ \"account\" ][ \"account_number\" ]) account . next_sequence = sequence account . account_number = account_number","title":"load_account_data()"},{"location":"transaction/types/","text":"Transaction Types Nearly every cosmos chain has its transaction types usually on top of the standard cosmos ones. Mospy supports some standard transaction types that should be the same on every chain. However, every chain can modify these and you would then need to implement that change by yourself. But this will be explained here. Data structures In general, the cosmos sdk uses the protobuf data format to define data structures. These protobuf files serve as documentation and help to serialize the data directly in your code. To make protobufs more accessible for python I am maintaining the cosmospy-protobuf library which contains all cosmos protobuf files compiled for python. Mospy is using cosmospy-protobuf. The naming scheme is following the official cosmos naming scheme. This is especially useful when working with different transaction types. Included transaction types Mospy ships some standard transaction types for easier implementation. Currently, following transaction types are supported: * MsgSend * MsgDelegate * MsgUndelegate * MsgWithdrawDelegatorReward Each transaction type takes different keyword arguments. You can check out the examples to see how to use each type. The following example will use the MsgSend type as it is the most common one: from mospy import Transaction, Account account = Account(...) tx = Transaction(...) tx.add_msg( tx_type='transfer', sender=account, receipient=\"cosmos1tkv9rquxr88r7snrg42kxdj9gsnfxxg028kuh9\", amount=1000, denom=\"uatom\" ) # Sign and broadcast The first argument always defines the transaction type. The following required arguments are then defined by each adapter. You have to use keyword arguments. Custom transaction types Transaction types that aren't integrated can be added to the transaction class through the add_raw_msg method. This function takes two arguments. The method takes two arguments. The first one is the msg data in the protobuf format and the second one is the type url. For instance, if you want to make a transaction that changes the reward withdraw address you will need to implement the transaction with the type /cosmos.distribution.v1beta1.MsgSetWithdrawAddress . The compiled protobuf files are available at cosmospy_protobuf.cosmos.distribution.v1beta1.tx_pb2 . To see what data you need to pass you can check out the according protobuf file in the cosmospy-protobuf repository: https://github.com/ctrl-Felix/cosmospy-protobuf/blob/main/src/cosmospy_protobuf/cosmos/distribution/v1beta1/tx.proto#L31 The full example will look like this: from mospy import Transaction from cosmospy_protobuf.cosmos.distribution.v1beta1.tx_pb2 import MsgSetWithdrawAddress tx = Transaction(...) wmsg = MsgSetWithdrawAddress( delegator_address=\"cosmos1...\", withdraw_address=\"cosmos1...\" ) tx.add_raw_msg(wmsg, type_url=\"/cosmos.distribution.v1beta1.MsgSetWithdrawAddress\") # Sign and broadcast You see! It's not complicated at all. Transaction body A transaction can have many messages with different transaction types. You can save a lot of fees by aggregating your messages into one big transaction. But keep in mind. If one message fails the whole transaction and all messages fail.","title":"Transaction Types"},{"location":"transaction/types/#transaction-types","text":"Nearly every cosmos chain has its transaction types usually on top of the standard cosmos ones. Mospy supports some standard transaction types that should be the same on every chain. However, every chain can modify these and you would then need to implement that change by yourself. But this will be explained here.","title":"Transaction Types"},{"location":"transaction/types/#data-structures","text":"In general, the cosmos sdk uses the protobuf data format to define data structures. These protobuf files serve as documentation and help to serialize the data directly in your code. To make protobufs more accessible for python I am maintaining the cosmospy-protobuf library which contains all cosmos protobuf files compiled for python. Mospy is using cosmospy-protobuf. The naming scheme is following the official cosmos naming scheme. This is especially useful when working with different transaction types.","title":"Data structures"},{"location":"transaction/types/#included-transaction-types","text":"Mospy ships some standard transaction types for easier implementation. Currently, following transaction types are supported: * MsgSend * MsgDelegate * MsgUndelegate * MsgWithdrawDelegatorReward Each transaction type takes different keyword arguments. You can check out the examples to see how to use each type. The following example will use the MsgSend type as it is the most common one: from mospy import Transaction, Account account = Account(...) tx = Transaction(...) tx.add_msg( tx_type='transfer', sender=account, receipient=\"cosmos1tkv9rquxr88r7snrg42kxdj9gsnfxxg028kuh9\", amount=1000, denom=\"uatom\" ) # Sign and broadcast The first argument always defines the transaction type. The following required arguments are then defined by each adapter. You have to use keyword arguments.","title":"Included transaction types"},{"location":"transaction/types/#custom-transaction-types","text":"Transaction types that aren't integrated can be added to the transaction class through the add_raw_msg method. This function takes two arguments. The method takes two arguments. The first one is the msg data in the protobuf format and the second one is the type url. For instance, if you want to make a transaction that changes the reward withdraw address you will need to implement the transaction with the type /cosmos.distribution.v1beta1.MsgSetWithdrawAddress . The compiled protobuf files are available at cosmospy_protobuf.cosmos.distribution.v1beta1.tx_pb2 . To see what data you need to pass you can check out the according protobuf file in the cosmospy-protobuf repository: https://github.com/ctrl-Felix/cosmospy-protobuf/blob/main/src/cosmospy_protobuf/cosmos/distribution/v1beta1/tx.proto#L31 The full example will look like this: from mospy import Transaction from cosmospy_protobuf.cosmos.distribution.v1beta1.tx_pb2 import MsgSetWithdrawAddress tx = Transaction(...) wmsg = MsgSetWithdrawAddress( delegator_address=\"cosmos1...\", withdraw_address=\"cosmos1...\" ) tx.add_raw_msg(wmsg, type_url=\"/cosmos.distribution.v1beta1.MsgSetWithdrawAddress\") # Sign and broadcast You see! It's not complicated at all.","title":"Custom transaction types"},{"location":"transaction/types/#transaction-body","text":"A transaction can have many messages with different transaction types. You can save a lot of fees by aggregating your messages into one big transaction. But keep in mind. If one message fails the whole transaction and all messages fail.","title":"Transaction body"}]}